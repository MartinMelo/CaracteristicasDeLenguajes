\documentclass[a4paper,12pt]{article}
\usepackage{fullpage}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[spanish]{babel}
\parindent 0pt
\usepackage{proof}        % Para escribir el infer y hacer la linea para la definicion inductiva*
\usepackage{amsmath,amssymb,graphicx}
\newcommand\fun{\textsf{fun}~}  % Una especie de macro para usar \fun
\newcommand\fix{\textsf{fix}~}
\newcommand\Let{\textsf{Let}~}
\newcommand\In{\textsf{in}~}
\newcommand\ifZ{\textsf{ifZ}~}
\newcommand\Nat{\textsf{Nat}~}
\newcommand\CL{\textsf{CL}~}
\newcommand\CR{\textsf{CR}~}
\newcommand\Node{\textsf{Node}~}
\newcommand\Leaf{\textsf{Leaf}~}
\newcommand\Tree{\textsf{Tree}~}
\newcommand\NoLeaf{\textsf{NoLeaf}~}
\newcommand\ifLeaf{\textsf{ifLeaf}~}
\newcommand\Then{~\textsf{then}~} % Uso mayúsculas para then y else porque en
\newcommand\Else{~\textsf{else}~} % minúsculas son palabras claves de LaTeX
 
\title{Trabajo Practico \\ Lenguajes segun sus caracteristicas}
\author{Martion Alejandro Melo}
\date{\today}
 
\begin{document}
\maketitle
 
\section{Rehacer las entregas}

\subsection{Entrega 1}

\subsection{Entrega 2}
\textsl{Extender PCF para disponer de Arboles Binarios} \\

	\textbf{Sintaxis de Tipos: } \\
	
	  $ A = \Nat | A\Rightarrow A | A\wedge A | \Tree A | \NoLeaf A $\\
	
	\textbf{Sintaxis de terminos:  } \\
	 
	$ t = ... | Leaf~t | Tree~t~t~t | ifLeaf~t\Then t\Else t | CL~t | CR~t | Node~t $ \\
	
	\textbf{Semantica Operacional:} \\
	
	$ \CL \Tree t~u~v\rightarrow u $  \\
	$ \CR \Tree t~u~v\rightarrow v $  \\
	$ \ifLeaf \Tree t~u~v\Then u\Else v\rightarrow v $  \\
	$ \ifLeaf \Leaf t\Then u\Else v\rightarrow u $  \\
	$ \Node \Tree t~u~v\rightarrow t $  \\
	$ \Node \Leaf t\rightarrow t $  \\
	
	
	\textbf{Relacion definida inductivamente:} \\
	
	\infer{\Gamma \vdash t : \Tree A}{\Gamma \vdash t : \NoLeaf A}
	\vspace{5mm}
	\infer{\Gamma \vdash \Leaf t : \Tree A}{\Gamma \vdash t : A}
	\vspace{5mm} 
	\infer{\Gamma \vdash \CL t: \Tree A }{\Gamma \vdash t : \NoLeaf}
	\vspace{5mm} 
	\infer{\Gamma \vdash \CR t: \Tree A }{\Gamma \vdash t : \NoLeaf}
	\vspace{5mm} 
	\infer{\Gamma \vdash \Node t: A }{\Gamma \vdash t : \Tree A}
	\vspace{5mm} 
	\infer{\Gamma \vdash \Tree t~r~l: \NoLeaf A }
				{ \Gamma \vdash l : \Tree A 
				& \Gamma \vdash r : \Tree A
				& \Gamma \vdash t : A
				}
	\vspace{5mm} 
	\infer{\Gamma \vdash \ifLeaf t~r~l: B }
				{ \Gamma \vdash l : B
				& \Gamma \vdash r : B
				& \Gamma \vdash t : \Tree A
				}
				
\subsection{Entrega 3}

\textsl{Extender Algoritmo de Hindley y Robinson para Arboles Binarios y derivar el tipo para el siguiente termino:} \\
	
	
	\text{\CL ( (\fun x.x) (\Leaf 2))} \\
	
	
	\textbf{Para Hindley:} \\
	
	
	\infer{\Gamma \vdash \Leaf t \leadsto A \rightarrow \Tree A,\phi  }{\Gamma \vdash t \leadsto A,\phi }
	\vspace{5mm}
	\infer{\Gamma \vdash \CL t \leadsto Tree A \rightarrow \Tree A,\Theta  }{\Gamma \vdash t \leadsto \NoLeaf A,\Theta }
	\vspace{5mm}
	\infer{\Gamma \vdash \CR t \leadsto Tree A \rightarrow \Tree A,\Theta  }{\Gamma \vdash t \leadsto \NoLeaf A,\Theta }
	\vspace{5mm}

	
	\textbf{Para Robinson:} \\
	(1) Cada vez que aparece Tree A => NoLeaf A, Dar error. \\
	(2) Cada vez que aparece NoLeaf A, Se puede reemplazar por Tree A. \\
	
\subsection{Entrega 4}
	\textbf{Derivar tipo con Hindley y Robinson a: Node ((fun x.leaf x) (fun y.y)).}
	\vspace{5mm}
	
	\infer{\Gamma \vdash \Node ((\fun x.\Leaf x) (\fun y.y)) \leadsto C, \{B\Rightarrow \Tree B = (A\Rightarrow A)\Rightarrow X , X= \Tree C \} }
		{	
			\infer{\Gamma \vdash (\fun x.\Leaf x) (\fun y.y)\leadsto X, \{B\Rightarrow \Tree B = (A\Rightarrow A)\Rightarrow X\}}
			{
			 \infer{\Gamma \vdash \fun x.\Leaf x \leadsto B \Rightarrow \Tree B, \emptyset}
				{
					\infer{x:B\vdash x \leadsto B, \emptyset}{}
				}
				& 
				\infer{\Gamma \vdash \fun y.y \leadsto A\Rightarrow A, \emptyset}
				{
					\infer{y:A\vdash y \leadsto A, \emptyset}{}
				}
			}	
		}
		\vspace{5mm}
		
		\textbf{Robinson}
		
		 
		\[ \left\{ 
		\begin{array}{ll}
					\mbox{ $ B\Rightarrow \Tree B = (A\Rightarrow A)\Rightarrow X $ }\\
					\mbox{X= \Tree C}
				\end{array}
		\right. \] 		
		$ \Rightarrow	(1)$
		\[ \left\{ 
		\begin{array}{ll}
					\mbox{ $ B = (A\Rightarrow A) $ }\\
					\mbox{ $ \Tree B = X $ }\\
					\mbox{X= \Tree C}
				\end{array}
		\right. \]
		$ \Rightarrow	(1)$
		\[ \left\{ 
		\begin{array}{ll}
					\mbox{ $ B = (A\Rightarrow A) $ }\\
					\mbox{ $ \Tree B = \Tree B $ }\\
					\mbox{ $ \Tree B = \Tree C $}
				\end{array}
		\right. \]
		$ \Rightarrow	(4)$
		\[ \left\{ 
		\begin{array}{ll}
					\mbox{ $ B = (A\Rightarrow A) $ }\\
					\mbox{ $ \Tree B = \Tree C $}\\
					\mbox{ $ B = C $}
				\end{array}
		\right. \]
		$ \Rightarrow	(1)$
		\[ \left\{ 
		\begin{array}{ll}
					\mbox{ $ (A\Rightarrow A) = (A\Rightarrow A) $ }\\
					\mbox{ $ \Tree (A\Rightarrow A) = \Tree C $}\\
					\mbox{ $ (A\Rightarrow A) = C $}
				\end{array}
		\right. \]
		
		$ S = [(A\Rightarrow A)/C] $ \\
		El tipo es: $ (A\Rightarrow A) $
		\vspace{5mm}	
		
	\textbf{Derivar tipos con polimorfismo a: Fun X.Let y=x in y y. }
	\vspace{5mm}
	
	\[
  \infer{\vdash\fun x.\Let y=x\In yy:[B\Rightarrow(A\Rightarrow A)]}
  {
    \infer{x:[B]\vdash\Let y=x\In yy:[A\Rightarrow A]}
    {
      \infer{x:[B]\vdash x:[B]}{}
      &
      \infer{x:[B],y:[B]\vdash yy:[A\Rightarrow A]}
      {
	\infer{x:[B],y:[B]\vdash y:[B\Rightarrow(A\Rightarrow A)]}{}
	&
	\infer{x:[B],y:[B]\vdash y:[B]}{}
      }
    }
  }
\]
	
	
\subsection{Entrega 5}

\[
   (\fun x.\fun y.(1+x)+4) ((\fun z.z*z)2)
\]


\section*{CBV fuerte y debil}
\begin{align}
  (\fun x.\fun y.(1+x)+4) ((\fun z.z*z)2) 
  & \to (\fun x.\fun y.(1+x)+4) (2*2)    \nonumber\\
  & \to (\fun x.\fun y.(1+x)+4) 4	 \nonumber\\
  & \to \fun y.(1+4)+4			 ~\textsl{fin debil}\nonumber\\
  & \to \fun y.~5+4			 \nonumber\\
  & \to \fun y.~9			 ~\textsl{fin fuerte} \nonumber 
\end{align}


\section*{CBN fuerte y debil}
\begin{align}
  (\fun x.\fun y.(1+x)+4) ((\fun z.z*z)2)	
  & \to \fun y.(1+((\fun z.z*z)2))+4     ~\textsl{fin debil}\nonumber\\
  & \to \fun y.(1+(2*2))+4  \nonumber\\
  & \to \fun y.(1+4)+4			  \nonumber\\
  & \to \fun y.~5+4			  \nonumber\\
  & \to \fun y.~9			 ~\textsl{fin fuerte} \nonumber				 
\end{align}



\subsection{Entrega 6}

\[
   (\fun x.x+x) ((\fun y.y)3)
\]
\textsl{CBN}\\
\begin{align*}
\scalebox{0.7}[0.7]{
			\infer{\vdash(\fun x.x+x) ((\fun y.y)3) \hookrightarrow 6}
				{
					\infer{\vdash \fun x.x+x \hookrightarrow <x,x+x,\varnothing>}{} 
					&
					\infer{x=<((\fun y.y)3),\varnothing>\vdash x+x \hookrightarrow 6}
					{
						\infer{x=<((\fun y.y)3),\varnothing> \vdash x \hookrightarrow 3}
						{
							\infer{\vdash(\fun y.y) 3 \hookrightarrow 3}
							{
								\infer{\vdash \fun y.y \hookrightarrow <y,y,\varnothing>}{}
								& 
								\infer{y=<3,\varnothing>\vdash 3 \hookrightarrow 3}
								{
									\infer{\vdash 3 \hookrightarrow 3}{}
								}
							}
						}
						&
						\infer{x=<((\fun y.y)3),\varnothing> \vdash x \hookrightarrow 3}
						{
							\infer{\vdash(\fun y.y) 3 \hookrightarrow 3}
							{
								\infer{\vdash \fun y.y \hookrightarrow <y,y,\varnothing>}{}
								& 
								\infer{y=<3,\varnothing>\vdash 3 \hookrightarrow 3}
								{
									\infer{\vdash 3 \hookrightarrow 3}{}
								}
							}
						}
					}
				}
		}
\end{align*}


\subsection{Entrega 7}

Agregar la multiplicacion al compilador.

Con lo cual a la definicion que ya teniamos agregariamos la operacion "mul" que multiplica el primero de la pila con el acumulador borrando el primero de la pila y poniendo el resultado en el acumulador.

La secuencia para $ (1+2)*3+1 $ seria la siguiente: ldi 1;push;ldi 2; add; push; ldi 3; mul; push; ldi 1; add;



\section{Responder las siguientes preguntas:}

2)
Que un lenguaje no sea tipado quiere decir que al momento de escribir el codigo no es necesario dar el tipo
de datos que se utiliza en las funciones, parametros, definiciones de variables.
Por ejemplo en Javascript las variables se pueden definir como "var nombre= dato" sin dar el tipo de la variable.
Si bien el lenguaje es no tipado, no quiere decir que posea inferencia de tipos.

3) La inferencia de tipo es la capacidad que permite al programador obviar la definicion del tipo de las funciones, declaraciones y/o variables.
 Ya que el sistema de inferencia de tipos los asigna "Automaticamente" al momento de interpretarlo o compilarlo.
Esta capacidad la poseen principal los lenguajes con chequeo estatico de tipos.
Los lenguajes mas conocidos con inferencia de tipos son Hakell, OCaml y Scala.

4)

5)Una estrategia de evaluacion determinado cuando evaluar los argumentos de la llamada de una funcion. Tambien determina el tipo del valor que le pasa. Todos los lenguajes de programacion utilizan una estrategia de evaluacion. Las principales estrategias son:
Call by value: Esta estrategia primero evalua los argumentos y luego evalua la funcion.
Call by name:  Esta estrategia primero evalua la funcion y luego cuando sea necesario evalua los argumentos.

Ambas tienen sus ventajas y sus desventajas.

6)Un interprete realiza la "traducion" a codigo maquina en tiempo de ejecucion, instruccion por instruccion. Esto permite que tanto el debuging del programa interpretado, la programacion y distribucion del programa sea mas flexible. Esta ultima caracteristica se da ya que al ser interpretado lo unico que se necesita
es un interprete especifico para cada plataforma.

7) Un compilador transforma el codigo escrito al codigo maquina previo a la ejecucion. Existen muchos tipos de compiladores, sus diferencias estan en 
las etapas de compilacion, el resultado final, etc. A su vez un compilador puede formar parte de un interprete.

8)Una maquina virtual interpreta un tipo de codigo especifico para el que este destinada y ejecuta sus instrucciones, su mayor ventaja es que permite la portabilidad del programa escrito, ya que el codigo esta destinado a que la maquina virtual lo entienda y no la plataforma donde esta corriendo. Con lo cual el programar se asegura que se va a obtener el mismo resultado/comportamiento en las disintas plataformas(hardware/software). Las maquinas virtuales mas conocidas son la de Java, Javascript,Smalltalks, Scala.

\end{document}